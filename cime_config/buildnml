#!/usr/bin/env python3

"""DART Namelist creator.
"""

# Typically ignore this.
# pylint: disable=invalid-name

# Disable these because this is our standard setup
# pylint: disable=wildcard-import,unused-wildcard-import

import os, sys, shutil

_CIMEROOT = os.getenv("CIMEROOT")
sys.path.append(os.path.join(_CIMEROOT, "scripts", "Tools"))

from standard_script_setup import *
from CIME.case import Case
from CIME.utils import expect, symlink_force
from CIME.buildnml import parse_input, create_namelist_infile

from dart_input_nml import DART_input_nml
from dart_input_data_list import DART_input_data_list

logger = logging.getLogger(__name__)

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def buildnml(case, caseroot, compname):
    """Generate and/or stage DART configuration files:
        (1) Check for configuration consistency.
        (2) Generate DART input.nml file.
            Set ensemble size based on number of ocean instances.
            Set ESP number of tasks.
        (3) Set DATA_ASSIMILATION_SCRIPT variable.
        (4) Stage sampling error correction
    """

    # Build the component namelist and required stream txt files
    if compname != "dart":
        raise AttributeError

    # Define commonly used variables:
    ###############################################################################

    caseroot = case.get_value("CASEROOT")
    dartroot = case.get_value("COMP_ROOT_DIR_ESP")
    rundir = case.get_value("RUNDIR")
    comp_ocn = case.get_value("COMP_OCN")
    ninst_ocn = int(case.get_value("NINST_OCN"))
    calendar = case.get_value("CALENDAR")
    buildnml_dir = os.path.dirname(os.path.abspath(__file__))

    # DATA_ASSIMILATION flag for each component
    data_assimilation = {
        cc: case.get_value(f"DATA_ASSIMILATION_{cc.upper()}")
        for cc in ["atm", "cpl", "ocn", "wav", "glc", "ice", "rof", "lnd"]
    }
    n_da_comp = sum(data_assimilation.values())

    # Determine configuration directory
    confdir = os.path.join(caseroot, "Buildconf", compname + "conf")
    if not os.path.isdir(confdir):
        os.makedirs(confdir)

    # Local buildnml function definitions:
    ###############################################################################
    
    def consistency_checks():
        expect(
            calendar == "GREGORIAN",
            "When DART is active, the model calendar must be GREGORIAN.",
        )
        #if data_assimilation["ocn"] is True:
        #    run_startdate = case.get_value("RUN_STARTDATE")
        #    run_startyear = run_startdate[:4] 
        #    expect(
        #        2005 <= int(run_startyear) <= 2016, # todo: instead of startdate, check out enddate
        #        "When ocean data assimilation is turned on, model date must be between 2005 and 2016 "
        #        "to ensure availability of obs files."
        #    )

    def gen_DART_input_nml():
        input_nml_template = os.path.join(
            dartroot, "param_templates", "json", "input_nml.json"
        )
        input_nml = DART_input_nml.from_json(input_nml_template)
        # ensemble size is number of ocean instances
        input_nml["filter_nml"]["ens_size"]["values"] = ninst_ocn

        # HK todo set ensemble_manager namelist based on number of tasks per node
        tasks_per_node = case.get_value("TASKS_PER_NODE")

        # Read user_nl_dart file and parse namelist
        user_nl_file = os.path.join(caseroot, "user_nl_dart")
        if os.path.exists(user_nl_file):
            user_nml = parse_fortran_namelist(user_nl_file)
            # Update input_nml with values from user_nl_dart
            for namelist_name, namelist_vars in user_nml.items():
                if namelist_name in input_nml.data:
                    for var_name, var_value in namelist_vars.items():
                        if var_name in input_nml.data[namelist_name]:
                            # Update the value in input_nml
                            input_nml.data[namelist_name][var_name]["values"] = var_value
                        else:
                            logger.warning(f"Variable {var_name} in {namelist_name} not found in template")
                else:
                    logger.warning(f"Namelist {namelist_name} not found in template")
    
        input_nml.write(os.path.join(confdir, "input.nml"), case)

        return input_nml

    def parse_fortran_namelist(filepath):
        """Simple parser for Fortran namelist files."""
        import re
        
        def convert_fortran_value(value_str):
            """Convert Fortran namelist value string to appropriate Python type."""
            value_str = value_str.strip()
            
            # Handle empty or quoted empty string
            if not value_str or value_str == "''":
                return ''
            
            # Handle booleans
            if value_str.lower() in ['.true.', 't']:
                return True
            if value_str.lower() in ['.false.', 'f']:
                return False
            
            # Handle comma-separated lists (arrays)
            if ',' in value_str:
                items = [convert_fortran_value(item.strip()) for item in value_str.split(',')]
                return items
            
            # Handle quoted strings
            if (value_str.startswith("'") and value_str.endswith("'")) or \
               (value_str.startswith('"') and value_str.endswith('"')):
                return value_str[1:-1]  # Remove quotes
            
            # Try to convert to number
            try:
                if '.' in value_str or 'e' in value_str.lower():
                    return float(value_str)
                else:
                    return int(value_str)
            except ValueError:
                # If all else fails, return as string
                return value_str
        
        nml_dict = {}
        current_nml = None
        
        with open(filepath, 'r') as f:
            lines = f.readlines()
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            i += 1
            
            # Skip empty lines and comments
            if not line or line.startswith('!'):
                continue
            
            # Start of namelist
            if line.startswith('&'):
                current_nml = line[1:].strip()
                nml_dict[current_nml] = {}
                continue
            
            # End of namelist
            if line.startswith('/'):
                current_nml = None
                continue
            
            # Parse variable assignment
            if current_nml and '=' in line:
                match = re.match(r'(\w+)\s*=\s*(.+)', line)
                if match:
                    var_name = match.group(1).strip()
                    var_value = match.group(2).strip()
                    
                    # Check if this is a multi-line value (ends with comma and not complete)
                    # Continue reading lines until we find one that doesn't end with a comma
                    # or we hit the end of the namelist
                    while var_value.rstrip().endswith(',') and i < len(lines):
                        next_line = lines[i].strip()
                        i += 1
                        
                        # Stop if we hit end of namelist or start of new namelist
                        if next_line.startswith('/') or next_line.startswith('&'):
                            i -= 1  # Back up so we process this line next iteration
                            break
                        
                        # Skip empty lines and comments in continuation
                        if not next_line or next_line.startswith('!'):
                            continue
                        
                        # Stop if we hit a new variable assignment
                        if '=' in next_line and not next_line.strip().startswith("'"):
                            i -= 1  # Back up so we process this line next iteration
                            break
                        
                        # Append the continuation line
                        var_value += ' ' + next_line.strip()
                    
                    # Remove trailing comma if present
                    var_value = var_value.rstrip(',').strip()
                    
                    # Convert to appropriate Python type
                    nml_dict[current_nml][var_name] = convert_fortran_value(var_value)

        return nml_dict

    def gen_input_data_list():
        """ Observational data for DART assimilation """
        # HK todo what to do with observations.
        input_data_list_template = os.path.join(
            dartroot, "param_templates", "json", "input_data_list.json"
        )
        dart_params = DART_input_data_list.from_json(input_data_list_template)
        dart_params.write(os.path.join(confdir, '..', "dart.input_data_list"), case)

    def set_cesm_data_assimilation_options():
        """Set case XML variables for data assimilation"""

        assim_script  = os.path.join(buildnml_dir, "assimilate.py")
        case.set_value("DATA_ASSIMILATION_SCRIPT", assim_script)
        case.set_value("NTASKS_ESP", ninst_ocn) # HK does CIME take care of NTASKS_PER_INST_ESP?

    def stage_sampling_error_correction(input_nml):
        """If requested, stage sampling error correction file."""

        sampling_error_correction = input_nml.data["assim_tools_nml"][
            "sampling_error_correction"
        ]["values"]
        if sampling_error_correction == ".true.":

            samp_err_file = os.path.join(
                dartroot,
                "DART",
                "assimilation_code",
                "programs",
                "gen_sampling_err_table",
                "work",
                "sampling_error_correction_table.nc",
            )
            if os.path.exists(samp_err_file):
                expect(
                    3 <= ninst_ocn <= 200,
                    f"sampling_error_correction_table.nc handles ensemble sizes 3...200. "
                    f"Yours is {ninst_ocn}.",
                )
                shutil.copy(samp_err_file, confdir)
            else:  # sampling_error_correction_table.nc file found
                expect(
                    sampling_error_correction != ".true.",
                    "No sampling_error_correction_table.nc file found...\n"
                    "The input.nml:assim_tool_nml:sampling_error_correction "
                    "is .true. so this file must exist.",
                )

    # Call local buildnml function definitions:
    ###############################################################################

    # few consistency checks
    consistency_checks()

    # generate DART_input_nml
    input_nml = gen_DART_input_nml()

    # generate input_data_list file - HK todo is this obs?
    gen_input_data_list()

    # set case xml variables for data assimilation
    set_cesm_data_assimilation_options()

    # stage sampling error correction, needs info from input_nml
    stage_sampling_error_correction(input_nml)

###############################################################################
def _main_func():
    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "dart")


if __name__ == "__main__":
    _main_func()
