#!/usr/bin/env python3

"""
build dart
"""
import sys, os, shutil

_CIMEROOT = os.environ.get("CIMEROOT")
if _CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")

_LIBDIR = os.path.join(_CIMEROOT, "scripts", "Tools")
sys.path.append(_LIBDIR)

from standard_script_setup import *
from CIME.buildlib import parse_input
from CIME.case import Case
from CIME.utils import run_sub_or_cmd, run_cmd, expect
from CIME.build import get_standard_makefile_args

logger = logging.getLogger(__name__)

def CESM_DART_config(case):
    '''
    Build the DART executables using the conventional DART scripts (quickbuild.sh et al.)
    In the future, this routine should be replaced by a build routine that actually takes
    advantage of CIME build infrastructure.
    '''

    logger.info("Building DART executables using quickbuild.sh")

    dartroot = case.get_value("COMP_ROOT_DIR_ESP")
    core_dartroot = os.path.join(dartroot,"DART")
    comp_ocn = case.get_value("COMP_OCN")
    exeroot = case.get_value("EXEROOT")
    caseroot = case.get_value("CASEROOT")
    # get this directory to get input.nml and mkmf.template
    buildlib_dir = os.path.dirname(os.path.abspath(__file__))

    # Number of model run - data assimilation steps to complete
    data_assimilation_cycles = case.get_value("DATA_ASSIMILATION_CYCLES")
    expect(data_assimilation_cycles>0, "DATA_ASSIMILATION_CYCLES must be greater than 0 when DART is active.")

    # DATA_ASSIMILATION flag for each component
    data_assimilation = {cc: case.get_value(f"DATA_ASSIMILATION_{cc.upper()}") \
                            for cc in ['atm', 'cpl', 'ocn', 'wav', 'glc', 'ice', 'rof', 'lnd'] }

    # number of components for which DA is on
    n_da_comp = sum(data_assimilation.values())

    # select the appropriate mkmf.template:
    compiler = case.get_value("COMPILER")
    build_templates_dir = os.path.join(buildlib_dir,os.pardir,"cesm_build_templates")
    mkmf_template = os.path.join(core_dartroot, "build_templates", "mkmf.template")
    
    if compiler == "intel":
        shutil.copy(os.path.join(build_templates_dir, "mkmf.template.intel.linux"), mkmf_template)
    elif compiler == "gnu":
        shutil.copy(os.path.join(build_templates_dir, "mkmf.template.gfortran"), mkmf_template)
    else:
        expect(False, "Unsupported compset for DATA_ASSIMILATION.")

    dart_executables = ['filter', 'perfect_model_obs', 'fill_inflation_restart']

    # Make sure the DART executables exist or build them if we can't find them.
    targetdir = os.path.join(exeroot,"esp")

    if not all([os.path.exists(os.path.join(targetdir,executable)) for executable in dart_executables]):
        logger.warning("DART executable(s) missing in build directory.\n"
                       "Trying to (re)build all executables now")
        
        # Create a symbolic link of preprocess_input.nml in bld dir
        preprocess_input_nml_path = os.path.join(build_templates_dir, "preprocess_input.nml") 
        bld_input_nml_path = os.path.join(targetdir, "input.nml") 
        if os.path.lexists(bld_input_nml_path):  # lexists will be true for broken symlinks
            os.remove(bld_input_nml_path)
        logger.info(f"linking {preprocess_input_nml_path} to {bld_input_nml_path}")
        os.symlink(preprocess_input_nml_path, bld_input_nml_path)

        # Create quickbuild.sh for this case
        # While doing so, change the relative DART path with the correct absolute DART path
        orig_quickbuild_path = os.path.join(build_templates_dir,"quickbuild.sh")
        new_quickbuild_path = os.path.join(targetdir,"quickbuild.sh")
        with open(new_quickbuild_path,'w') as f:
            for line in open(orig_quickbuild_path,'r'):
                if not line.startswith('export DART='):
                    f.write(line)
                else:
                    f.write(f"export DART='{core_dartroot}'\n")

        # Now, run the quickbuld.sh command
        os.chdir(targetdir)
        cmd = "sh ./quickbuild.sh"
        rc, out, err = run_cmd(cmd)
        logger.info("%s: \n\n output:\n %s \n\n err:\n\n%s\n"%(cmd,out,err))
        expect(rc == 0, "Command %s failed with rc=%s" % (cmd, rc))

    # Stage the DART executables in the CESM execution root directory
    # HK Why is is this the root directory and not the esp directory?
    #for executable in dart_executables:
    #    shutil.copy(os.path.join(targetdir,executable), exeroot)

    # Note: the remaining CESM_DART_config tasks are done in buildnml.

    else:
        logger.info("DART executables exist")

def buildlib(caseroot, libroot, bldroot):
    '''The top-level buildlib function.'''

    # build a pseudo-DART library (consisting of a dummy nuopc driver only).
    with Case(caseroot) as case:
        # first check for the external FMS library and build it
        logger.info("Building DART")
        objroot = case.get_value("OBJROOT")
        dartroot = case.get_value("COMP_ROOT_DIR_ESP")
        caseroot = case.get_value("CASEROOT")
        casetools = case.get_value("CASETOOLS")
        gmake_j = case.get_value("GMAKE_J")
        gmake = case.get_value("GMAKE")

        # create Filepath
        # HK do we have to have source mods for DART?
        filepath_file = os.path.join(objroot, "esp", "obj", "Filepath")
        if not os.path.isfile(filepath_file):
            paths = [
                os.path.join(caseroot,"SourceMods","src.dart"), # todo, this SourceMods dir doesn't exist yet
                os.path.join(objroot, "esp", "source"),
                os.path.join(dartroot, "nuopc_driver")
                ]

            with open(filepath_file, 'w') as filepath:
                filepath.write("\n".join(paths))
                filepath.write("\n")

        os.chdir(bldroot)

        # build the library
        makefile = os.path.join(casetools, "Makefile")
        complib = os.path.join(libroot,"libesp.a")
        cmd = f"{gmake} complib -j {gmake_j} COMP_NAME=dart COMPLIB={complib} " +\
              f"-f {makefile} {get_standard_makefile_args(case)}"

        rc, out, err = run_cmd(cmd)
        logger.info("%s: \n\n output:\n %s \n\n err:\n\n%s\n"%(cmd,out,err))
        expect(rc == 0, "Command %s failed with rc=%s" % (cmd, rc))

        CESM_DART_config(case)

def _main_func():
    caseroot, libroot, bldroot = parse_input(sys.argv)
    buildlib(caseroot, libroot, bldroot)

###############################################################################

if __name__ == "__main__":
    _main_func()
